group proto_meta;

var_type_dict ::= [
               "INT32": "STAT_TYPE_INT32",
               "int":   "STAT_TYPE_INT32",
               "INT":   "STAT_TYPE_INT32",
               "CHAR":  "STAT_TYPE_BYTE",
               "char":  "STAT_TYPE_CHAR",
               "INT16": "STAT_TYPE_SHORT",
               "short": "STAT_TYPE_SHORT",
               "UINT16":"STAT_TYPE_USHORT",
               "BYTE":  "STAT_TYPE_BYTE",
               "UINT8": "STAT_TYPE_BYTE",
               "UINT32":"STAT_TYPE_UINT32",
               "uint":  "STAT_TYPE_UINT32",
               "float": "STAT_TYPE_FLOAT",
               "FLOAT": "STAT_TYPE_FLOAT",
               "string": "STAT_TYPE_STRING",
               "bool": "STAT_TYPE_BOOL",
               "INT64": "STAT_TYPE_INT64",
               "UINT64": "STAT_TYPE_UINT64",
               default:key
]

cpp_header(include, content) ::= <<
// -----------------------------------------------------------------------
// This file was generated by protoc v2.0, DONT not modify mannual.
// ----------------------------------------------------------------------  
#include <persistence/DbMeta.h>

$include$

$content$

>>
      
prog(stmts) ::= <<
$stmts$
>>

import_stmt(module) ::= <<
>>

include(module) ::= <<
#include <common/protocol/$module$.pb.h>

>>

comm_var(type, name, order) ::= <<

>>

fixstr_var(type, name, order) ::= <<

>>

key(is_primary) ::= <<
$if(is_primary)$
DB_PRIMARY_KEY
$else$
DB_NORMAL_FIELD
$endif$
>>

type(is_fix_str, type) ::= <<
$if(is_fix_str)$
STAT_TYPE_STRING
$else$
$var_type_dict.(type)$
$endif$
>>

required_var(type, name, order, is_fix_str, len, is_primary, class_name) ::= <<
FIELD_DEFINE($name$, $type(is_fix_str=is_fix_str, type=type)$, $class_name$, $order$, $key(is_primary=is_primary)$, $len$)
>>

repeated_var(type, name) ::= <<
> > > > ERROR
>>

field_stmt(label, type, name, order, is_fix_str, len, is_primary, class_name) ::= <<
$(label+"_var")(type=type, name=name, order=order, is_fix_str=is_fix_str, len=len, is_primary=is_primary, class_name=class_name)$
>>

nest_field(parent, class_name) ::= <<
COMPOUND_FIELD_DEF($it.id$, $parent$, $type(is_fix_str=it.is_fix_str, type=it.type)$, $class_name$, $it.order$, $key(is_primary=it.is_primary)$, $it.fix_str_len$)
>>

custom_field_stmt(name, ref_type, class_name) ::= <<
    $ref_type.fields:nest_field(parent=name, class_name=class_name);separator=",\n"$                        
>>

declare_stmt(f) ::= <<
$(f.label+"_var")(type=f.type, name=f.id)$
>>
   
var_list(FIELD_LIST) ::= <<
$FIELD_LIST:declare_stmt(); separator="\n"$
>>

param_name(name) ::= <<
$name$_
>>

required_param(type, name) ::= <<
$type$ $param_name(name)$
>>

repeated_param(type, name) ::= <<
const std::vector<$type$>& $param_name(name)$
>>

para_var(f) ::= <<
$(f.label+"_param")(type=f.type, name=f.id)$
>>

var_init(name) ::= <<
$name$($param_name(name)$)
>>

init_var(f) ::= <<
$var_init(name=f.id)$
>>

init_default_var(f) ::= <<
$f.id$()
>>

embed_enum_specifier(id, list) ::= <<
>>

enum_specifier(id, list) ::= <<
>>

enumerator(id, value) ::= <<
>>

add(a, b) ::= <<
>>

struct_stmt(classname, stat_list, field_list, db_table, db_obj_type) ::= <<
$if(db_table)$
$meta_define(class_name=classname, stat_list=stat_list, field_list=field_list, db_table=db_table, db_obj_type=db_obj_type)$
$else$
$endif$
>>

class_stmt() ::= <<
>>

message_stmt() ::= <<
>>

comment() ::= <<
>>

meta_define(class_name, stat_list, field_list, db_table, db_obj_type) ::= <<
static DB_FIELD_DEFINE s_table_meta_$class_name$
{
    $stat_list; separator=",\n"$
};

REGISTER_TABLE_SCHEMA($db_table$, $db_obj_type$, sizeof($class_name$), s_table_meta_$class_name$,
                      countof(s_table_meta_$class_name$));


>>

