group proto_as;


var_type_dict ::= [
               "INT32": "int",
               "int":   "int",
               "INT":   "int",
               "CHAR":  "int",
               "char":  "int",
               "INT16": "int",
               "short": "int",
               "UINT16":"uint",
               "BYTE":  "uint",
               "UINT8": "uint",
               "UINT32":"uint",
               "uint":  "uint",
               "float": "Number",
               "FLOAT": "Number",
               "string": "String",
               "bool": "Boolean",
               default:key
]

stream_type_dict ::= [
               "INT32": "Int", 
               "int":   "Int", 
               "INT":   "Int", 
               "CHAR":  "Byte",
               "char":  "Byte",
               "INT16": "Short",                             
               "short": "Short",
               "UINT16":"UnsignedShort",
               "BYTE":  "UnsignedByte", 
               "UINT8": "UnsignedByte", 
               "UINT32":"UnsignedInt", 
               "uint":  "UnsignedInt", 
               "float": "Float",
               "FLOAT": "Float",
               "string": "UTF",
               "bool": "Byte"
]


cpp_header(file_guard_marco, content) ::= <<
/// This file was generated by protoc v2.0.
package onwind.protocol.CharMessage
{
    import flash.utils.ByteArray;
    import onwind.net.ProtocolBuffer;
    import onwind.net.INT64;
    import onwind.net.UINT64;
    import onwind.protocol.MessageType;

    $content$

}
>>
      
prog(stmts) ::= <<
$stmts; separator="\n\n"$
>>

import_stmt(module) ::= <<
import onwind.protocol.$module$.*;
>>

required_var(type, name) ::= <<
public var $name$:$var_type_dict.(type)$;
>>

repeated_var(type, name) ::= <<
public var $name$:Array; /* array of $type$/
>>

field_stmt(label, type, name) ::= <<
$(label+"_var")(type=type, name=name)$
>>

declare_stmt(f) ::= <<
$(f.label+"_var")(type=f.type, name=f.id)$
>>
   
var_list(FIELD_LIST) ::= <<
$FIELD_LIST:declare_stmt(); separator="\n"$
>>

param_name(name) ::= <<
$name$_
>>

required_param(type, name) ::= <<
$type$ $param_name(name)$
>>

repeated_param(type, name) ::= <<
const std::vector<$type$>& $param_name(name)$
>>

para_var(f) ::= <<
$(f.label+"_param")(type=f.type, name=f.id)$
>>

var_init(name) ::= <<
$name$($param_name(name)$)
>>

init_var(f) ::= <<
$var_init(name=last(f))$
>>

init_default_var(f) ::= <<
$last(f)$()
>>

required_plain_read(type, name) ::= <<
$name$=stream.read$stream_type_dict.(type)$();
>>

required_custom_read(type, name) ::= <<
$name$ = new $type$;
$name$.readFromStream(stream);
>>

repeated_plain_read(type, name) ::= <<
var length:int = stream.ReadH();
$name$ = [];
for (var i:int = 0; i < length; ++i) 
{
    $name$[i] = stream.read$stream_type_dict.(type)$();
}
>>

repeated_custom_read(type, name) ::= <<
var length:int = stream.ReadH();
$name$ = [];
for (var i:int = 0; i < length; ++i) 
{
    $name$[i] = new $type$;
    $name$[i].readFromStream(stream);
}
>>


read_stmt(f) ::= <<
$(f.label+"_"+f.method+"_read")(type=f.type, name=f.id)$
>>

required_plain_write(type, name) ::= <<
stream.write$stream_type_dict.(type)$($name$);
>>

required_custom_write(type, name) ::= <<
$name$.writeToStream(stream);
>>

repeated_plain_write(type, name) ::= <<
stream.writeShort($name$.length);
for(var i:int = 0; i < $name$.length; i++)
{
    stream.write$stream_type_dict.(type)$($name$[i]);
}
>>

repeated_custom_write(type, name) ::= <<
stream.writeShort($name$.length);
for(var i:int = 0; i < $name$.length; i++)
{
    $name$[i].writeToStream(stream);
}
>>

write_stmt(f) ::= <<
$(f.label+"_"+f.method+"_write")(type=f.type, name=f.id)$
>>

message_stmt(classname, stat_list, field_list) ::= <<
public class $classname$ : public PacketBase
{
    $stat_list; separator="\n"$

    /// overload operator\>\>, read from stream 
    public function readFromStram(stream:ByteArray):void
    {
        $field_list:read_stmt(); separator="\n"$
    }

    /// oerverload operator<<, write to stream
    public function writeToStream(stream:ByteArray):void
    {
        $field_list:write_stmt(); separator="\n"$                            
    }

    public function buildPacket():ByteArray
    {
        var abuff:ByteArray = ProtocolBuffer.NewBuffer();
        abuff.writeShort(THIS_MSG_TYPE);
        abuff.writeUnsignedInt(0);
        abuff.writeUnsignedInt(0);
        abuff.writeUnsignedInt(0);
        writeToStream(abuff);
        return abuff;
    }
};
>>

enum_specifier(id, list) ::= <<
public final class $id$ 
{
    $list; separator="\n"$
};
>>

embed_enum_specifier(id, list) ::= <<
$list; separator="\n"$
>>

enumerator(id, value) ::= <<
public static const $id$:int = $value$;   
>>

add(a, b) ::= <<
    $a$ + $b$
>>

struct_stmt(classname, stat_list, field_list) ::= <<
public class $classname$
{
    $stat_list; separator="\n"$

    /// overload operator\>\>, read from stream 
    public function readFromStram(stream:ByteArray):void
    {
        $field_list:read_stmt(); separator="\n"$
    }

    /// oerverload operator<<, write to stream
    public function writeToStream(stream:ByteArray):void
    {
        $field_list:write_stmt(); separator="\n"$                            
    }
};
>>
