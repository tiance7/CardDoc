group proto_cpp;

cpp_header(file_guard_marco, content) ::= <<
/// This file was generated by protoc v2.0.
#ifndef $file_guard_marco$
#define $file_guard_marco$
#include <common/protocol/PacketBase.h>

$content$

#endif // $file_guard_marco$
>>
      
prog(stmts) ::= <<
$stmts; separator="\n\n"$
>>

import_stmt(module) ::= <<
#include <common/protocol/$module$.pb.h>
>>

required_var(type, name) ::= <<
$type$ $name$;

>>

repeated_var(type, name) ::= <<
std::vector<$type$> $name$;

>>

field_stmt(label, type, name) ::= <<
$(label+"_var")(type=type, name=name)$
>>

declare_stmt(f) ::= <<
$(f.label+"_var")(type=f.type, name=f.id)$
>>
   
var_list(FIELD_LIST) ::= <<
$FIELD_LIST:declare_stmt(); separator="\n"$
>>

param_name(name) ::= <<
$name$_
>>

required_param(type, name) ::= <<
$type$ $param_name(name)$
>>

repeated_param(type, name) ::= <<
const std::vector<$type$>& $param_name(name)$
>>

para_var(f) ::= <<
$(f.label+"_param")(type=f.type, name=f.id)$
>>

var_init(name) ::= <<
$name$($param_name(name)$)
>>

init_var(f) ::= <<
$var_init(name=f.id)$
>>

init_default_var(f) ::= <<
$f.id$()
>>

required_read(name) ::= <<
inputStream \>\> v.$name$;
>>

repeated_read(name) ::= <<
{
     size_t n = inputStream.ReadH();
     v.$name$.resize(n);
     for (size_t i = 0; i < n; ++i) { inputStream \>\> v.$name$[i]; };
}    
>>

read_stmt(f) ::= <<
$(f.label+"_read")(name=f.id)$
>>

required_write(name) ::= <<
outputStream << v.$name$;
>>

repeated_write(name) ::= <<
outputStream << static_cast<UINT16>(v.$name$.size());
for(size_t i = 0; i < v.$name$.size(); ++i) { outputStream << v.$name$[i]; }
>>

write_stmt(f) ::= <<
$(f.label+"_write")(name=f.id)$
>>

message_stmt(classname, field_list, enum_list) ::= <<
class $classname$ : public PacketBase
{
public:
    $stat_list$

    /// read constructor 
    explicit $classname$(FiMessage* pMsg)
    : PacketBase(pMsg)
    {
        GetStream() \>\> *this;
    }

    /// write constructor
    $classname$(ClientId cid$field_list:para_var()$)
    : PacketBase(THIS_MSG_TYPE, cid, DEFAULT_PACKET_SIZE)
    , $field_list:init_var(); separator=", "$ 
    {
        GetStream() << *this;
    }

    /// overload operator\>\>, read from stream 
    friend FiMessage& operator\>\>(FiMessage& inputStream,  $classname$& v)
    {
        $field_list:read_stmt(); separator="\n"$
        return inputStream;
    }

    /// overload operator<<, write to stream
    friend FiMessage& operator<<(FiMessage& outputStream, $classname$& v)
    {
        $field_list:write_stmt(); separator="\n"$                            
        return outputStream;
    }
};
>>

embed_enum_specifier(id, list) ::= <<
$enum_specifier(id=id, list=list)$
>>

enum_specifier(id, list) ::= <<
enum $id$ {
$list; separator="\n"$
};

>>

enumerator(id, value) ::= <<
    $id$ = $value$,
>>

add(a, b) ::= <<
    $a$ + $b$
>>

struct_stmt(classname, stat_list, field_list) ::= <<
class $classname$
{
public:
    $stat_list$
    /// read constructor 
    explicit $classname$()
    : $field_list:init_default_var(); separator=", "$
    {
    }

    /// write constructor
    explicit $classname$($field_list:para_var(); separator=", "$)
    : $field_list:init_var(); separator=", "$ 
    {
    }

    /// overload operator\>\>, read from stream 
    friend FiMessage& operator\>\>(FiMessage& inputStream,  $classname$& v)
    {
        $field_list:read_stmt(); separator="\n"$
        return inputStream;
    }

    /// oerverload operator<<, write to stream
    friend FiMessage& operator<<(FiMessage& outputStream, $classname$& v)
    {
        $field_list:write_stmt(); separator="\n"$                            
        return outputStream;
    }
};
>>
